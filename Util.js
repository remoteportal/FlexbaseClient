// Generated by CoffeeScript 2.3.0
//if node
var MMSS, N, NODE_util, O, abort, exitAfterSlightDelay__soThatLogCanFinishWriting, fs, fs_directoryDeleteRecursive, fs_directoryEnsure, latestGet, logBase, m_logEmptyNextCharacter, m_logStream, trace;

fs = require('fs');

NODE_util = require('util');

//elseif rn
//import Expo, { FileSystem } from 'expo'
//endif
N = require('./N');

O = require('./O');

trace = require('./trace');

m_logStream = null;

m_logEmptyNextCharacter = 'A';

//TODO: log multiple objects before options

//H: try to move these into concrete S, N, O, etc., files???
abort = function(msg) {
  //if node
  console.error("#".repeat(60));
  if (msg) {
    console.error(`NODE ABORTED${(msg ? `: ${msg}` : "")}`);
  } else {
    console.error("ABORTING NOW!!! (log will be truncated...)");
  }
  console.error("#".repeat(60));
  return process.exit(1);
};

//else
//		throw "ABOPT!!!!!!!!!!!!!!!!!!"
//endif
exitAfterSlightDelay__soThatLogCanFinishWriting = function(ms = 500) {
  return setTimeout(() => {
    console.error("exitAfterSlightDelay__soThatLogCanFinishWriting");
    return process.exit(1);
  }, ms);
};

fs_directoryEnsure = function(directory, cb) {
  //		console.log "fs_directoryEnsure: #{directory}"
  return fs.access(directory, fs.constants.W_OK, (err) => {
    if (err) {
      if (err.code === "ENOENT") {
        //					@log "mkdir: #{directory}"
        return fs.mkdir(directory, (err) => {
          if (err) {
            //							@logError "mkdir", err
            return cb(err);
          } else {
            return cb();
          }
        });
      } else {
        //					@logError "access", err
        O.LOG(err);
        return cb(err);
      }
    } else {
      //				@log "already exists"
      return cb();
    }
  });
};

fs_directoryDeleteRecursive = function(directory) {
  //	console.log "fs_directoryDeleteRecursive: #{directory}"
  if (fs.existsSync(directory)) {
    fs.readdirSync(directory).forEach(function(file, index) {
      var curPath;
      curPath = directory + '/' + file;
      if (fs.lstatSync(curPath).isDirectory()) {
        return fs_directoryDeleteRecursive(curPath);
      } else {
        console.log(`fs_directoryDeleteRecursive: unlink: ${curPath}`);
        return fs.unlinkSync(curPath);
      }
    });
    return fs.rmdirSync(directory);
  }
};

// usage:
// fnn, s, v, bDeep
// fnn, s, v0, v1, ..., vN		where any v can be opts object
logBase = function(fnn, s, v, optionsObjectOrO_LOG_flag) { //H #MESS
  var a, bFoundOpts, ex, extra, i, j, k, len, len1, line, opt, opts, pn, pv, ref, ref1, ref2, vPart;
  //	console.log "logBase"
  //	O.LOG arguments
  //	abort()
  opts = {
    bVisible: true,
    bDeep: true //RECENT
  };
  
  //	a = arguments.slice()
  // copy array
  a = Array.prototype.slice.call(arguments, 1);
  //	O.LOG a
  //	abort()

  // ARGUMENTS SHIFT LEFT!
  // now:
  //	0	1	2
  //	s, v, opt
  //	O.LOG a
  if (a.length === 3 && typeof optionsObjectOrO_LOG_flag === "boolean") {
    opts.bDeep = optionsObjectOrO_LOG_flag;
    //		console.log "boolean passed as third argument: bDeep=#{opts.bDeep}"
    a.splice(2, 1);
  }
  //		O.LOG a
  //		console.log "len=#{a.length}"
  //	abort()
  if (a.length > 2) {
    ref = [0, a.length - 1];
    //		console.log "look for options object"
    //		O.LOG a
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      //			O.LOG a[i]
      if (typeof a[i] === "object") {
        bFoundOpts = false;
        ref1 = ["bDeep", "bVisible"];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          opt = ref1[k];
          if (opt in a[i]) {
            ref2 = a[i];
            // override specific opts
            for (pn in ref2) {
              pv = ref2[pn];
              //							console.log "opt: override: #{pn}=#{a[i][pn]}"
              opts[pn] = a[i][pn];
            }
          }
        }
      }
    }
  }
  //	console.log "FUCKING MESS"

  // log() draws a "horizontal rule" line of chars if no string passed
  //	console.log "s=#{s}"
  if (!s) {
    a.push(m_logEmptyNextCharacter.repeat(60));
    m_logEmptyNextCharacter = String.fromCharCode(m_logEmptyNextCharacter.charCodeAt(0) + 1);
  }
  vPart = "";
  extra = "";
  try {
    if (v != null) {
      if (v instanceof Error) {
        extra = `: ${v.stack}`;
      } else if (typeof v === "object") {
        if (!opts.bDeep) {
          extra = ` ${JSON.stringify(v)}`;
        }
      } else {
        extra = ` ${v}`;
      }
    }
  } catch (error) {
    ex = error;
    extra = `: LOG_BASE INTERNAL EXCEPTION: ${ex}`;
  }
  line = `${MMSS()} [${fnn}] ${s}${extra}`;
  if (opts.bVisible) {
    console.log(line);
    if (opts.bDeep && v) {
      //			console.log "*****************"
      O.LOG(v);
    }
  }
  //		O.LOG a...
  if (m_logStream != null) {
    return m_logStream.write(`${line}\n`);
  }
};

latestGet = function(clo, fq) {
  var latest, version;
  version = 0;
  while (clo[`version${version + 1}`]) {
    version++;
  }
  //	logBase "util", "version=#{version}"
  if (latest = clo[`version${version}`]) {
    return latest;
  } else {
    logBase("util", `[${fq}] Can't find version`, clo, true);
    return null;
  }
};

MMSS = function() {
  var date;
  return `${N.ZEROPAD((date = new Date).getMinutes(), 2)}:${N.ZEROPAD(date.getSeconds(), 2)}`;
};

module.exports = {
  abort: abort,
  exit: function(msg) {
    m_logStream.end(`\n--EOF but PREMATURE EXIT: ${msg}--`);
    m_logStream = null;
    //if node
    console.error("#".repeat(60));
    if (msg) {
      console.error(msg);
    } else {
      console.error("told to exit");
    }
    console.error("#".repeat(60));
    console.error("Exiting node...");
    return exitAfterSlightDelay__soThatLogCanFinishWriting();
  },
  //else
  //		console.error "#".repeat 60
  //		if msg
  //			console.error msg
  //		else
  //			console.error "EXIT NOT POSSIBLE"
  //		console.error "#".repeat 60
  //endif
  fs_directoryEnsure: fs_directoryEnsure,
  fs_directoryEnsurePromise: function(directory) {
    return NODE_util.promisify(fs_directoryEnsure)(directory);
  },
  fs_directoryDeleteRecursive: fs_directoryDeleteRecursive,
  latestGet: latestGet,
  logBase: logBase,
  streamSet: function(_) {
    return m_logStream = _;
  }
};
