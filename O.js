// Generated by CoffeeScript 2.3.0
/*
O - Object Functions					*** PROJECT AGNOSTIC ***

WHAT: Node module

DESCRIPTION

FEATURES
-

NOTES
-

TODOs
- LOG: pass explicit opts
- LOG: maxDepth option
- LOG: look at arguments.length to see if any passed parameters are undefined or null and PUT IN ALL CAPS!
- LOG: Object.getOwnProperty to show hidden (non-enumerable) properties

KNOWN BUGS:
-
*/
var A_CLR_ENUM, CLR_ENUM, CNT, CNT_ENUM, CNT_ENUM_OWN, CNT_OWN, CONTAINS_INSENSITIVE, DFS_BREAKABLE, KEYS, KEYS_ENUM, KEYS_ENUM_OWN, KEYS_OWN, LOG, LOGIgnore, V, duck, stringifySafe, trace;

//if node
trace = require('./trace');

//UT = require './UT'
V = require('./V');

//endif

//MOVE: to pre-processor
//H: what are the differences between these?
//UT: UT-ize
CNT = function(o) {
  var a;
  a = [];
  while (true) {
    a.push.apply(a, Object.getOwnPropertyNames(o));
    if (!(o = Object.getPrototypeOf(o))) {
      break;
    }
  }
  return a.length;
};

CNT_OWN = function(o) {
  return Object.getOwnPropertyNames(o).length;
};

CNT_ENUM = function(o) {
  var k, n;
  n = 0;
  for (k in o) {
    n++;
  }
  return n;
};

CNT_ENUM_OWN = function(o) {
  return Object.keys(o).length;
};

KEYS = function(o) {
  var a;
  a = [];
  while (true) {
    a.push.apply(a, Object.getOwnPropertyNames(o));
    if (!(o = Object.getPrototypeOf(o))) {
      break;
    }
  }
  return a;
};

KEYS_OWN = function(o) {
  return Object.getOwnPropertyNames(o);
};

KEYS_ENUM = function(o) {
  var a, k;
  a = [];
  for (k in o) {
    a.push(k);
  }
  return a;
};

KEYS_ENUM_OWN = function(o) {
  return Object.keys(o);
};

CLR_ENUM = function(o) {
  var k;
  for (k in o) {
    delete o[k];
  }
  return o;
};

A_CLR_ENUM = function() {
  var j, l, ref;
  for (j = l = 0, ref = arguments.length - 1; (0 <= ref ? l <= ref : l >= ref); j = 0 <= ref ? ++l : --l) {
    CLR_ENUM(arguments[j]);
  }
};

CONTAINS_INSENSITIVE = function(haystack, needle) {
  return S.CONTAINS_INSENSITIVE("" + haystack, "" + needle);
};

DFS_BREAKABLE = function(o, fn) { //REC
  var DFS_, bContinue;
  bContinue = true;
  DFS_ = function(o, depth) {
    var dt, idx, k, l, len, v;
    for (k in o) {
      v = o[k];
      switch (dt = IS.dt(v)) {
        case "a":
          if (!(bContinue = fn(o, k, v, dt, depth))) {
            return false;
          }
          for (idx = l = 0, len = v.length; l < len; idx = ++l) {
            V = v[idx];
            dt = IS.dt(v);
            if (!(bContinue = fn(v, idx, V, dt, depth))) {
              return false;
            }
            if (dt === "o") {
              if (!(bContinue = DFS_(V, depth + 1))) {
                return false;
              }
            }
          }
          return;
        case "o":
          if (!(bContinue = fn(o, k, v, dt, depth))) {
            return false;
          }
          if (!(bContinue = DFS_(v, depth + 1))) {
            return false;
          }
          break;
        default:
          if (!(bContinue = fn(o, k, v, dt, depth))) {
            return false;
          }
      }
    }
    return true;
  };
  return DFS_(o, 0);
};

LOGIgnore = {};

duck = function(o) {
  switch (false) {
    case !o.hasOwnProperty("__cn"):
      return "Flexbase object";
    case !o.hasOwnProperty("__CLASS_NAME"):
      return o.__CLASS_NAME;
    default:
      return "OBJ";
  }
};

//TODO: flag 'undefined' unless opt set
LOG = function(o) {
  var DEBUG, MAX_DEPTH, MAX_PROPERTY_DEPTH, Q, bRecurse, i, l, len, len1, log, m, objectFoundNbr, propertyHitsMap, v;
  DEBUG = 0;
  //	iter = 0
  //	MAX_ITER = 100
  MAX_DEPTH = 15;
  MAX_PROPERTY_DEPTH = 5;
  if (DEBUG) {
    console.log("\n\n\n\n\n\n\n\n\n\n");
    console.log("O.LOG:");
    console.log(JSON.stringify(o));
    console.log(`O.LOG: o=${o} ARRAY=${Array.isArray(o)} TYPEOF=${typeof o}) TYPE=${Object.prototype.toString.call(o)} JSON=${JSON.stringify(o)}`);
    console.log("===============================================");
  }
  Q = ">  ";
  propertyHitsMap = Object.create(null);
  bRecurse = true;
  log = function(p, v, depth) {
    var a, arg, cnt, ex, i, indent, item, l, len, len1, len2, len3, m, n, pn, q, r, results, results1, results2, results3, type;
    //TODO: use V.TYPE
    type = Object.prototype.toString.call(v);
    
    //		console.log "DEBUG: #{p}=#{v} ARRAY=#{Array.isArray v} TYPEOF=#{typeof v} TYPE2=#{type} JSON=#{JSON.stringify v}"

    //TODO: pass p as parameter
    indent = function(s) {
      return console.log(`${Q}${" ".repeat(depth * 8)}${(depth > 0 ? " âˆŸ " : "")}${(p.length > 0 ? `${p}:` : "")} ${s}`);
    };
    if (depth === MAX_DEPTH) {
      indent(`MAX_DEPTH (${MAX_DEPTH}) exceeded`);
      bRecurse = false;
      return;
    }
    if (Array.isArray(v)) {
      if (v.length === 0) {
        return indent("[]");
      } else {
        indent(`ARRAY (len=${v.length}):`);
        results = [];
        for (n = l = 0, len = v.length; l < len; n = ++l) {
          item = v[n];
          results.push(log(`${(p.length > 0 && p[0] !== '[' ? "" : "")}[${n}]`, item, depth + 1));
        }
        return results;
      }
    } else if (v instanceof Error) {
      indent("details:");
      a = Object.getOwnPropertyNames(v);
      results1 = [];
      for (m = 0, len1 = a.length; m < len1; m++) {
        pn = a[m];
        results1.push(log(pn, v[pn], depth + 1));
      }
      return results1;
    } else if (type === '[object Arguments]') {
      indent(`found arguments (length=${v.length})`);
      results2 = [];
      for (i = q = 0, len2 = v.length; q < len2; i = ++q) {
        arg = v[i];
        //				indent "arguments[#{i}] = #{arg}"

        //				indent "arguments[#{i}] ===================="
        //				LOG arg
        results2.push(log(`arguments[${i}]`, arg, depth + 1));
      }
      return results2;
    } else if (type === '[object Object]') {
      if (cnt = CNT_OWN(v)) {
        try {
          indent(`${duck(v)} (${cnt})`);
        } catch (error) {
          ex = error;
          indent(`duck exception (${cnt})`);
        }
        //				for p of v
        //					console.log "of: p=#{p}"

        //				#NOTE: "including non-enumerable properties except for those which use Symbol"
        //				for p in Object.getOwnPropertyNames v
        //					console.log "Object.getOwnPropertyNames: p=#{p}"

        //TODO: identify non-enumerable properties just because!
        a = Object.keys(v);
        a.sort();
        results3 = [];
        for (r = 0, len3 = a.length; r < len3; r++) {
          p = a[r];
          if (propertyHitsMap[p] != null) {
            if (++propertyHitsMap[p] === MAX_PROPERTY_DEPTH) {
              indent(`########## property '${p}' has occurred too many times.  Stopped at ${MAX_PROPERTY_DEPTH}.  Circular structure?`);
              bRecurse = false;
            }
          } else {
            propertyHitsMap[p] = 1;
          }
          if (bRecurse) {
            if (LOGIgnore[p]) {
              results3.push(log(p, "**LogIgnore**", depth + 1));
            } else {
              results3.push(log(p, v[p], depth + 1));
            }
          } else {
            results3.push(void 0);
          }
        }
        return results3;
      } else {
        return indent("OBJ EMPTY");
      }
    } else {
      return indent(V.DUMP(v));
    }
  };
  if (arguments.length === 0) {
    console.log("WARNING: LOG wasn't passed anything");
  } else if (arguments.length === 1) {
    log("", o, 0);
  } else {
    if (true) {
      objectFoundNbr = 0;
      for (i = l = 0, len = arguments.length; l < len; i = ++l) {
        v = arguments[i];
        if (v == null) {
          console.log(`${Q}LOGARG[${i}]: UNDEFINED`);
        } else if (Object.prototype.toString.call(v) === '[object String]') {
          //				console.log "#{v}"	# echo plain strings out directly as we find them
          console.log(`${Q}LOGARG[${i}]: ${V.DUMP(v)}`);
        } else {
          //				log "#{["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","next","next","next"][objectFoundNbr++]} OBJ PASSED", v, 0
          log(`LOGARG[${i}]:`, v, 0);
        }
      }
    } else {
      //TODO: put on a same line
      objectFoundNbr = 0;
      for (i = m = 0, len1 = arguments.length; m < len1; i = ++m) {
        v = arguments[i];
        if (v == null) {
          console.log(`${Q}LOGARG[${i}]: UNDEFINED`);
        } else if (Object.prototype.toString.call(v) === '[object String]') {
          //				console.log "#{v}"	# echo plain strings out directly as we find them
          console.log(`${Q}LOGARG[${i}]: ${V.DUMP(v)}`);
        } else {
          //				log "#{["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","next","next","next"][objectFoundNbr++]} OBJ PASSED", v, 0
          log(`LOGARG[${i}]:`, v, 0);
        }
      }
    }
  }
  if (DEBUG) {
    console.log("\n\n\n\n\n\n\n\n\n\n");
  }
};

stringifySafe = function(o) {
  var pn, s;
  if (o !== null && typeof o === 'object') {
    s = "";
    for (pn in o) {
      s += `${pn}=\${o[pn]} `;
    }
    return s;
  } else {
    return o;
  }
};

module.exports = {
  //	CLR_ENUM:CLR_ENUM
  //	A_CLR_ENUM:A_CLR_ENUM
  //	CONTAINS_INSENSITIVE:CONTAINS_INSENSITIVE
  //	DFS_BREAKABLE: DFS_BREAKABLE
  //	DELTA: (o0, o1) ->
  //		for k of o1
  //			delete o0[k]
  //		o0
  //	DIFF: (a, b) ->												# a-b
  //		o = Object.create null
  //		for pn in KEYS a
  //			o[pn] = b[pn] if pn !of b
  //		o
  EQUALS: function(o0, o1) {
    var compareTwo, leftChain, rightChain;
    leftChain = rightChain = null; //CLOSURE
    return compareTwo = function(o0, o1) {
      // remember that NaN===NaN returns false and isNaN(undefined) returns true
      //GETTING: 0x800a1389 - Microsoft JScript runtime error: Number expected
      //if !(o0 instanceof Object and o1 instanceof Object)
      if (Object.prototype.toString.call(o0) === "[object Object]" && Object.prototype.toString.call(o1) === "[object Object]") {
        if (Object.keys(o0).length === 0 && Object.keys(o1).length === 0) {
          return true;
        }
      } else {
        if (isNaN(o0) && isNaN(o1) && typeof o0 === 'number' && typeof o1 === 'number') {
          return true;
        }
      }
      if (o0 === o1) {
        // compare primitives and functions
        // check if both arguments reference the same object
        // especially useful on step when comparing prototypes
        return true;
      }
      if (o0 && !o1 || !o0 && o1) {
        //IMPROVED: seems like "no brainer???"
        return false;
      }
    };
  },
  // works in case when functions are created in constructor
  // comparing dates is a common scenario. Another built-ins?
  // we can even handle functions passed across iframes
  // precedence: instanceOf then && then ||
  //			if typeof o0 is 'function' and typeof o1 is 'function'									or
  //				o0 instanceof Date		and	o1 instanceof Date										or
  //				o0 instanceof RegExp	and	o1 instanceof RegExp									or
  //				o0 instanceof String	and	o1 instanceof String									r
  //				o0 instanceof Number	and	o1 instanceof Number
  //return o0.toString() is o1.toString()
  //return o0.toString().replace /~/g, "|"  is o1.toString().replace / /g, ""
  //				return o0.toString().replace(/\ /g, "") is o1.toString().replace /\ /g, ""

  //			#IMPROVED: seems like "no brainer???"
  //			return false if Object.keys(o0).length isnt Object.keys(o1).length

  //			# check for infinitive linking loops
  //			return false if leftChain.indexOf(o0) >= 0 || rightChain.indexOf(o1) >= 0
  //#
  //			# quick checking of one object being a subset of another
  //			#OPTIM: cache the structure of arguments[0]
  //			for k of o1
  //#return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if Object::hasOwnProperty.call(o0, k) isnt Object::hasOwnProperty.call(o1, k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //			for k of o0
  //#return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if Object::hasOwnProperty.call(o0, k) isnt Object::hasOwnProperty.call(o1, k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //				switch typeof o0[k]
  //					when 'object', 'function'
  //#CASE: NON-PRIMITIVE
  //						leftChain.push o0
  //						rightChain.push o1

  //						return false if !compareTwo o0[k], o1[k]

  //						leftChain.pop()
  //						rightChain.pop()
  //					else
  //#CASE: PRIMITIVE
  //						return false if o0[k] isnt o1[k]

  //			# at last checking prototypes as good as we can
  //			#home grown objects don't neccessary inherit from Object: return false if !(o0 instanceof Object && o1 instanceof Object)
  //			#return false if o0.isPrototypeOf(o1) || o1.isPrototypeOf(o0)
  //			return false if Object::isPrototypeOf.call(o0, o1) || Object::isPrototypeOf.call(o1, o0)
  //			return false if o0.constructor isnt o1.constructor
  //			return false if o0.prototype isnt o1.prototype

  //			true												#END: compareTwo

  //		for j in [1..arguments.length-1]
  //			leftChain = []
  //			rightChain = []

  //			return false if !compareTwo arguments[0], arguments[j]

  //		true#/EQUALS
  //	EQUALS_OBJECTS_THAT_ARE_CHAINED_TO_OBJECT_PROTOTYPE: (o0, o1) ->#NOT-USED
  //		leftChain=rightChain=null								#CLOSURE

  //		compareTwo = (o0, o1) ->
  //# remember that NaN===NaN returns false and isNaN(undefined) returns true
  //			return true if isNaN(o0) && isNaN(o1) && typeof o0 is 'number' && typeof o1 is 'number'

  //			# compare primitives and functions
  //			# check if both arguments reference the same object
  //			# especially useful on step when comparing prototypes
  //			return true if o0 is o1

  //			#IMPROVED: seems like "no brainer???"
  //			return false if o0 and !o1 or !o0 and o1

  //			# works in case when functions are created in constructor
  //			# comparing dates is a common scenario. Another built-ins?
  //			# we can even handle functions passed across iframes
  //			# precedence: instanceOf then && then ||
  //			if	typeof o0 is 'function'	&&	typeof o1 is 'function'									||
  //				o0 instanceof Date		&&	o1 instanceof Date										||
  //				o0 instanceof RegExp	&&	o1 instanceof RegExp									||
  //				o0 instanceof String	&&	o1 instanceof String									||
  //				o0 instanceof Number	&&	o1 instanceof Number
  //#return o0.toString() is o1.toString()
  //#return o0.toString().replace /~/g, "|"  is o1.toString().replace / /g, ""
  //				return o0.toString().replace(/\ /g, "") is o1.toString().replace /\ /g, ""

  //			# at last checking prototypes as good as we can
  //			return false if !(o0 instanceof Object && o1 instanceof Object)
  //			return false if o0.isPrototypeOf(o1) || o1.isPrototypeOf(o0)
  //			return false if o0.constructor isnt o1.constructor
  //			return false if o0.prototype isnt o1.prototype

  //			#IMPROVED: seems like "no brainer???"
  //			return false if Object.keys(o0).length isnt Object.keys(o1).length

  //			# check for infinitive linking loops
  //			return false if leftChain.indexOf(o0) >= 0 || rightChain.indexOf(o1) >= 0

  //			# quick checking of one object being a subset of another
  //			#OPTIM: cache the structure of arguments[0]
  //			for k of o1
  //				return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //			for k of o0
  //				return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //				switch typeof o0[k]
  //					when 'object', 'function'
  //#CASE: NON-PRIMITIVE
  //						leftChain.push o0
  //						rightChain.push o1

  //						return false if !compareTwo o0[k], o1[k]

  //						leftChain.pop()
  //						rightChain.pop()
  //					else
  //#CASE: PRIMITIVE
  //						return false if o0[k] isnt o1[k]

  //			true												#END: compareTwo

  //		for j in [1..arguments.length-1]
  //			leftChain = []
  //			rightChain = []

  //			return false if !compareTwo arguments[0], arguments[j]

  //		true#/EQUALS_OBJECTS_THAT_ARE_CHAINED_TO_OBJECT_PROTOTYPE
  //	I: (o) ->
  //		if typeof o is "number"
  //			o
  //		else
  //			parseInt o, 10
  //	IS_EMPTY: (o) ->
  //		for k of @KEYS o
  //			return false
  //		true

  CNT: CNT,
  CNT_OWN: CNT_OWN,
  CNT_ENUM: CNT_ENUM,
  CNT_ENUM_OWN: CNT_ENUM_OWN,
  duck: duck,
  INTERSECTS_ENUM: function(o0, o1) {
    var k;
    for (k in o0) {
      if (k in o1) {
        return true;
      }
    }
    return false;
  },
  KEYS: KEYS,
  KEYS_OWN: KEYS_OWN,
  KEYS_ENUM: KEYS_ENUM,
  KEYS_ENUM_OWN: KEYS_ENUM_OWN,
  LOG: LOG,
  LOGIgnore: LOGIgnore,
  
  //	N: (o) ->
  //		if typeof o is "number"
  //			o
  //		else if R.RE.TEST_PLUS_MINUS_FLOAT.test o
  //			parseFloat o, 10
  //		else
  //			throw o
  //	SUB_SUP_PROP_VALUES_EQUALS: (sub, sup) ->
  //		for k of sub
  //			return false unless sup[k]?
  //			return false unless R.O.EQUALS sub[k], sup[k]
  //		true
  UTRun: function() {
    this.log("O.UTRun");
    //if ut
    return new O_UT().run();
  }
};

//endif

//class O_UT extends UT
//	run: ->
//		@T "LOG", ->
//			@log "pre"
