// Generated by CoffeeScript 2.3.0
//if node
var Base, Classes, Client, ClientUT, O, Store, UT, WebSocket, trace, util;

WebSocket = require('ws');

//A = require './A'
Base = require('./Base');

Classes = require('./Classes');

O = require('./O');

Store = require('./Store');

trace = require('./trace');

UT = require('./UT');

util = require('./Util');

//endif

// TODO
ClientUT = class ClientUT extends UT {
  run(testHub1) {
    this.testHub = testHub1;
    return this.s("negative", function() {
      return this.a("non-existent server", {
        timeout: 2000
      }, function(ut) {
        this.client = new Client("www.onlyup.com");
        return this.client.listen(true).then((connectedCnt) => {
          this.log(`client connected: connectedCnt=${connectedCnt}`);
          return this.client.send({
            c_to_s: "hi"
          });
        //				.then (fo) =>
        //					@log "read", fo
        //					@log fo.pi()
        //					@eq fo.pi(), 3.1415926
        //					ut.resolve()
        }).catch((ex) => {
          //					O.LOG ex
          if (ex === "Invalid URL") {
            this.log("correct");
            this.client.listen(false);
            return ut.resolve();
          } else {
            this.logCatch(this.context, ex);
            return ut.reject(ex);
          }
        });
      });
    });
  }

};

//endif
Client = class Client extends Base {
  constructor(URL) {
    super();
    this.URL = URL;
    //		@_who = "class Client"
    this.bAlive = this.bNoConnectionDisplayed = false;
    this.onCloseErrorMap = {};
  }

  //		@log "Client"																				if trace.CONSTRUCTORS
  //		throw new Error "THIS FORCES STACKTRACE"
  attempt() {
    var ex;
    //TODO: #H: leave @ off of @bAlive and notice no error displayed... fix the root cause of this!
    //		@log "attempt: bAlive=#{@bAlive}"
    if (this.bAlive) {
      if (trace.SOCKET_NOISE) {
        this.log(`[${this.attemptCnt}] attempt: ws=${this.ws} mOnline=${this.mOnline}`);
      }
      if (!this.ws) {
        this.attemptCnt++;
        if (trace.SOCKET_NOISE) {
          this.log(`[${this.attemptCnt}] attempting to connect to WebSocket ${this.URL}`);
        }
        this.mOnline = 1;
        try {
          // https://github.com/websockets/ws
          this.ws = new WebSocket(this.URL);
        } catch (error) {
          ex = error;
          //				@log "type=#{typeof ex.message}"
          if (ex.message.includes("Invalid URL")) {
            //					@logFatal "bad url: #{@URL}"
            this.listen_reject("Invalid URL");
            clearInterval(this.thread);
            return;
          } else {
            this.logCatch("new WebSocket", ex);
            clearInterval(this.thread);
            this.listen_reject(ex);
            this.logFatal("INVESTIGATE", ex);
            return;
          }
        }
        this.ws.onopen = () => {
          this.connectedCnt++;
          if (trace.INTERNET) {
            this.log(`Internet connected: connectedCnt=${this.connectedCnt}`);
          }
          this.bConnected = true;
          this.attemptCnt = 0;
          this.mOnline = 2;
          return this.listen_resolve(this.connectedCnt);
        };
        this.ws.onmessage = (e) => {
          var o;
          //					@log "msg", e.data

          //							o = JSON.parse e.data
          //							if o.target is "flexbase"
          //								@log "FB: onmessage: #{e.data}"
          //							if @ws_onmessage o
          //								@mOnline = 3
          o = JSON.parse(e.data);
          return this.onReceive(o);
        };
        this.ws.onerror = (ex) => {
          //								@logFatal "onerror", ex		#LONG
          //								@log "type=#{Object::toString.call ex}"
          this.logFatal(`onerror: ${ex.message //, ex	#LONG
}`);
          if (ex.message.includes("Connection refused")) { // The operation couldnâ€™t be completed. Connection refused
            if (!this.bNoConnectionDisplayed) {
              this.log("No Internet connection");
              this.mOnline = 4;
              //TODO: display to user
              this.bNoConnectionDisplayed = true;
            }
          } else {
            this.logError(`onerror: ${ex.message}`, ex);
            O.LOG(ex);
          }
          // util.dumpSafeRecursive(ex);
          // 1001 websocket "stream end encountered"
          // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
          // 1000: Normal closure; the connection successfully completed whatever purpose for which it was created.
          return this.ws = null;
        };
        return this.ws.onclose = (ex) => {
          var _;
          //				@log "onclose", ex, false		#CIRCULAR
          //					@log "onclose"
          if (this.bConnected) {
            _ = `onclose: code=${ex.code} reason=${ex.reason}`;
            if (!this.onCloseErrorMap[_]) {
              this.onCloseErrorMap[_] = true;
            }
            //							@log _
            return this.ws = null;
          }
        };
      }
    }
  }

  listen(bAlive) {
    var ref;
    this.bAlive = bAlive;
    if (this.bAlive) {
      return new Promise((listen_resolve, listen_reject) => {
        this.listen_resolve = listen_resolve;
        this.listen_reject = listen_reject;
        //				@log "bAlive=#{@bAlive} connect: #{@URL}"
        if (this.ws) {
          return this.listen_reject("already started!");
        } else if (this.URL) {
          this.mOnline = 0;
          this.uptimeBeg = Date.now(); //H
          this.bConnected = false;
          this.attemptCnt = 0;
          this.connectedCnt = 0;
          this.attempt();
          //TODO: clearInterval @thread
          return this.thread = setInterval(() => {
            return this.attempt();
          }, 5000);
        } else {
          return this.logFatal("URL unset");
        }
      });
    } else {
      //			@log "stopping... bAlive=#{@bAlive}"
      clearInterval(this.thread);
      return (ref = this.ws) != null ? ref.close() : void 0;
    }
  }

  //.catch (ex) => @logCatch "tank of gas", ex
  onReceive(o) {}

  //		@log "onReceive [DEFAULT]", o
  send(o) {
    //		@log "send", o
    //H #BIZARRE #BACKED_OUT passing the callback breaks receiving good data on the server
    //			@ws.send JSON.stringify o, (err) =>
    //			@log "sent"
    //			if err
    //				@logTransient "send:ws.send", err
    return this.ws.send(JSON.stringify(o));
  }

  //		@log "SEND"

  //// If the WebSocket is closed before the following send is attempted
  //ws.send('something');

  //// Errors (both immediate and async write errors) can be detected in an optional
  //// callback. The callback is also the only way of being notified that data has
  //// actually been sent.
  //ws.send('something', function ack(error) {
  //// If error is not defined, the send has been completed, otherwise the error
  //// object will indicate what failed.
  //});

  //// Immediate errors can also be handled with `try...catch`, but **note** that
  //// since sends are inherently asynchronous, socket write failures will *not* be
  //// captured when this technique is used.
  //try { ws.send('something'); }
  //catch (e) { /* handle error */ }

  //if ut
  static s_ut(testHub) {
    return new ClientUT().run(testHub);
  }

};

//endif
module.exports = Client;
