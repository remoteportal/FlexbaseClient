// Generated by CoffeeScript 2.3.0
//if node
var GUIDNew, MMSS, N, NODE_util, O, fs, fs_directoryDeleteRecursive, fs_directoryEnsure, latestGet, logBase, stringifySafe, trace;

fs = require('fs');

NODE_util = require('util');

//elseif rn
//import Expo, { FileSystem } from 'expo'
//endif
N = require('./N');

O = require('./O');

trace = require('./trace');

stringifySafe = function(o) {
  var pn, s;
  if (o !== null && typeof o === 'object') {
    s = "";
    for (pn in o) {
      s += `${pn}=\${o[pn]} `;
    }
    return s;
  } else {
    return o;
  }
};

fs_directoryEnsure = function(directory, cb) {
  //		console.log "fs_directoryEnsure: #{directory}"
  return fs.access(directory, fs.constants.W_OK, (err) => {
    if (err) {
      if (err.code === "ENOENT") {
        //					@log "mkdir: #{directory}"
        return fs.mkdir(directory, (err) => {
          if (err) {
            //							@logError "mkdir", err
            return cb(err);
          } else {
            return cb();
          }
        });
      } else {
        //					@logError "access", err
        O.DUMP(err);
        return cb(err);
      }
    } else {
      //				@log "already exists"
      return cb();
    }
  });
};

fs_directoryDeleteRecursive = function(directory) {
  //	console.log "fs_directoryDeleteRecursive: #{directory}"
  if (fs.existsSync(directory)) {
    fs.readdirSync(directory).forEach(function(file, index) {
      var curPath;
      curPath = directory + '/' + file;
      if (fs.lstatSync(curPath).isDirectory()) {
        return fs_directoryDeleteRecursive(curPath);
      } else {
        console.log(`fs_directoryDeleteRecursive: unlink: ${curPath}`);
        return fs.unlinkSync(curPath);
      }
    });
    return fs.rmdirSync(directory);
  }
};

logBase = function(fnn, s, v, opt) {
  var ex, vPart;
  vPart = "";
  if (s == null) {
    s = "**********";
  }
  try {
    if (v != null) {
      if (("" + v) === "[object Object]") {
        if (opt) {
          vPart = "";
          O.DUMP(v); //NOT-DEBUG
        } else {
          vPart = " " + JSON.stringify(v);
        }
      } else {
        vPart = v;
      }
    } else {
      vPart = "";
    }
    return console.log(`${MMSS()} [${fnn}] ${s} ${vPart}`);
  } catch (error) {
    ex = error;
    return console.log(`${MMSS()} [${fnn}] ${s}: LOG EXCEPTION: ${ex}`);
  }
};

GUIDNew = function() { // uuidv4
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r, v;
    r = Math.random() * 16 | 0;
    v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

// console.log uuidv4()
latestGet = function(clo, fq) {
  var latest, version;
  version = 0;
  while (clo[`version${version + 1}`]) {
    version++;
  }
  //	logBase "util", "version=#{version}"
  if (latest = clo[`version${version}`]) {
    return latest;
  } else {
    logBase("util", `[${fq}] Can't find version`, clo, true);
    return null;
  }
};

MMSS = function() {
  var date;
  return `${N.ZEROPAD((date = new Date).getMinutes(), 2)}:${N.ZEROPAD(date.getSeconds(), 2)}`;
};

//util =

//	log: (s, o) ->			logBase "Util", s, o
//	logError: (s, o) ->		logBase "Util", "ERROR: #{s}", o
//	logCatch: (s, o) ->		logBase "Util", "CATCH: #{s}", o

//	dumpSafe: (v) ->
//		@log "dumpSafe"

//		if v and typeof v is 'object'
//			for pn, pv of v
//				@log "#{pn}=#{pv}"
//		else
//			@log v
//		return

//	dumpSafeRecursive: (v) ->
//#		@log "dumpSafeRecursive"

//		if v and typeof v is 'object'
//			for pn, pv of v
//				if pv and typeof pv is 'object'
//#					util.dumpSafeRecursive pv			#TODO: stops prematurely
//					@log "DSR: #{pn} OBJ"
//				else
//					@log "DSR: #{pn}=#{pv}"
//		else
//			@log "DSR: #{v}"
//		return
module.exports = {
  fs_directoryEnsure: fs_directoryEnsure,
  fs_directoryEnsurePromise: function(directory) {
    return NODE_util.promisify(fs_directoryEnsure)(directory);
  },
  fs_directoryDeleteRecursive: fs_directoryDeleteRecursive,
  GUIDNew: GUIDNew,
  latestGet: latestGet,
  logBase: logBase
};
