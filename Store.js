// Generated by CoffeeScript 2.3.0
/*
Store - multi-threaded safe filesystem read and writes

EXTENDS: Base

DESCRIPTION

FEATURES
-

TODOs
- UTRun isn't stack
- non-standard factory pattern

KNOWN BUGS:
-
*/
var A, Base, O, Store, StoreUT, UT, factory, fs, path, trace, util;

//if node
fs = require('fs');

path = require('path');

//elseif rn
//import Expo, { FileSystem, SQLite } from 'expo'
//endif
A = require('./A');

Base = require('./Base');

O = require('./O');

trace = require('./trace');

UT = require('./UT');

util = require('./Util');

//if ut
StoreUT = class StoreUT extends UT {
  constructor() {
    super("StoreUT");
  }

  run() {
    //		@a "HELP", (ut) ->
    //			store = factory "/tmp/StoreUT"
    //			ut.resolve()
    this.a("concurrent writes", function(ut) {
      var a, store;
      //			@log "****777** hello: #{@peter}"
      //			@log "hello"
      a = [];
      store = factory("/tmp/ConcurrentWrites");
      return store.init().then(() => {
        a.push(store.write(1, {
          a: "first"
        }));
        a.push(store.write(1, {
          a: "second"
        }));
        a.push(store.write(1, {
          a: "third"
        }));
        a.push(store.write(2, {
          b: "b value"
        }));
        a.push(store.write(3, {
          c: "c value"
        }));
        return Promise.all(a);
      }).then((a2) => {
        //				@log "all written", a2
        a = [];
        a.push(store.read(1));
        a.push(store.read(1));
        a.push(store.read(1));
        a.push(store.read(2));
        a.push(store.read(2));
        a.push(store.read(3));
        return Promise.all(a);
      }).then((a2) => {
        //				@log "all read", a2
        return ut.resolve();
      }).catch((ex) => {
        return this.logCatch("How I got rid of long-term plantar fasciitis", ex);
      });
    });
    //			@log "exit but may still have stuff running"
    return this.a("2nd", function(ut) {
      //			@log "2nd"
      return ut.resolve();
    });
  }

};

//endif
Store = class Store extends Base {
  constructor(directory1) {
    super("IGNORE");
    this.directory = directory1;
    if (trace.CONSTRUCTORS) {
      this.log(`Store: directory=${this.directory}`);
    }
    this.map = {};
  }

  destroy() {
    return this.log("DESTROY");
  }

  init() {
    //		@log "init: directory=#{@directory}"
    return util.fs_directoryEnsurePromise(this.directory);
  }

  //	init: ->
  //		new Promise (resolve, reject) =>
  //			@log "init: directory=#{@directory}"
  //			util.fs_directoryEnsurePromise @directory
  //			.then =>
  //				@log "directory ensured"
  //				resolve()
  //			.catch (ex) =>
  //				@logCatch "blah", ex
  //				reject ex
  //		666;
  json(substitute) {
    return path.join(this.directory, `${substitute}.json`);
  }

  metaCreateAndCache(__id) {
    return this.map[__id] = {
      o: null,
      bReading: false,
      readList: [],
      writeList: []
    };
  }

  // read object.  If subsequent read while first read in progress then queue and notify once first is finished
  //SIG: get(__id, ~degree)... look at piece of paper...
  read(id) {
    return new Promise((resolve, reject) => {
      var meta;
      if (!(meta = this.map[id])) {
        meta = this.metaCreateAndCache(id);
      }
      if (meta.o) {
        //				@log "get #{id} hit"
        return resolve(meta.o);
      } else if (meta.bReading) {
        //				@log "get #{id} read in progress"
        return meta.readList.unshift({
          resolve: resolve,
          reject: reject
        });
      } else {
        //				@log "get #{id} read from disk"
        meta.bReading = true;
        //if node
        return fs.readFile(this.json(id), (err, data) => {
          var notify;
          //elseif rn
          //				Expo.FileSystem.readAsStringAsync(@json("object#{id}")).then (json) =>
          //				o = JSON.parse json
          //endif
          //					@log "get #{id} done: #{data.length} bytes"
          notify = function(method, o) {
            var i, len, reader, ref;
            meta.bReading = false;
            ref = meta.readList;
            for (i = 0, len = ref.length; i < len; i++) {
              reader = ref[i];
              reader[method](o);
            }
            return meta.readList.length = 0;
          };
          if (err) {
            if (err.code !== "ENOENT") {
              this.logError("readFile", err, true);
            }
            notify("reject", data);
            return reject(err);
          } else {
            meta.o = data;
            resolve(data);
            return notify("resolve", data);
          }
        });
      }
    });
  }

  write(id, o) {
    //OPTIMIZE: no reason to write intermediate copies
    return new Promise((resolve, reject) => {
      var fnWriteNextObject, meta;
      if (!(meta = this.map[id])) {
        meta = this.metaCreateAndCache(id);
      }
      //			@log "#{meta.writeList.length} in progress"
      meta.writeList.unshift({
        o: o,
        resolve: resolve,
        reject: reject
      });
      if (meta.writeList.length === 1) {
        fnWriteNextObject = () => {
          //if node
          return fs.writeFile(this.json(id), JSON.stringify(o), (err) => {
            var rec2;
            //elseif rn
            //						Expo.FileSystem.writeAsStringAsync flexbase_HELP.path("object#{@id}"), json
            //endif
            //							@log "write done"
            rec2 = meta.writeList.pop();
            if (err) {
              this.logError("writeFile", err);
              return rec2.reject(err);
            } else {
              //							@log "succ: #{meta.writeList.length}"
              rec2.resolve(id);
              if (meta.writeList.length > 0) {
                //								@log "more waiting!"
                o = meta.writeList[0];
                return fnWriteNextObject();
              }
            }
          });
        };
        return fnWriteNextObject();
      }
    });
  }

};

factory = function(directory) {
  return new Store(directory);
};

module.exports = {
  //if ut
  UTRun: function() {
    return new StoreUT().run();
  },
  //endif
  factory: factory
};
