// Generated by CoffeeScript 2.3.0
//if node
var A_CLR_ENUM, B, CLR_ENUM, CNT, CNT_ENUM, CNT_ENUM_OWN, CNT_OWN, CONTAINS_INSENSITIVE, DFS_BREAKABLE, DUMP, KEYS, KEYS_ENUM, KEYS_ENUM_OWN, KEYS_OWN, V, a, l, o, trace;

trace = require('./trace');

V = require('./V');

//endif

//import logBase from './Log'
if (0) {
  // probably long
  o = Object.create(null);
  o["1"] = true;
  o["3"] = true;
  o["5"] = true;
  // probably short
  a = [1, 2, 3, 4];
  // iterate a, check o

  // optimize: some objects are 'everyone'
  o.$ = 3;
  o.$a = 33;
  o.$$ = 2;
  o.a = [1, 2, 3];
  o.a.total = 100;
  l = o.a.length;
}

//IS=R.IS
B = function(o) {
  return o === true || o === 1 || o === "1" || o === "true";
};

CLR_ENUM = function(o) {
  var k;
  for (k in o) {
    delete o[k];
  }
  return o;
};

A_CLR_ENUM = function() {
  var i, j, ref;
  for (j = i = 0, ref = arguments.length - 1; (0 <= ref ? i <= ref : i >= ref); j = 0 <= ref ? ++i : --i) {
    CLR_ENUM(arguments[j]);
  }
};

CONTAINS_INSENSITIVE = function(haystack, needle) {
  return S.CONTAINS_INSENSITIVE("" + haystack, "" + needle);
};

DFS_BREAKABLE = function(o, fn) { //REC
  var DFS_, bContinue;
  bContinue = true;
  DFS_ = function(o, depth) {
    var dt, i, idx, k, len, v;
    for (k in o) {
      v = o[k];
      switch (dt = IS.dt(v)) {
        case "a":
          if (!(bContinue = fn(o, k, v, dt, depth))) {
            return false;
          }
          for (idx = i = 0, len = v.length; i < len; idx = ++i) {
            V = v[idx];
            dt = IS.dt(v);
            if (!(bContinue = fn(v, idx, V, dt, depth))) {
              return false;
            }
            if (dt === "o") {
              if (!(bContinue = DFS_(V, depth + 1))) {
                return false;
              }
            }
          }
          return;
        case "o":
          if (!(bContinue = fn(o, k, v, dt, depth))) {
            return false;
          }
          if (!(bContinue = DFS_(v, depth + 1))) {
            return false;
          }
          break;
        default:
          if (!(bContinue = fn(o, k, v, dt, depth))) {
            return false;
          }
      }
    }
    return true;
  };
  return DFS_(o, 0);
};

//V.DUMP = (v) ->
//	if Object::toString.call(v) is '[object String]'
//		if v.length is 0
//			"\"\""
//		else
//			v
//	else if Object::toString.call(v) is '[object Number]'
//		v
//	else if Object::toString.call(v) is '[object Boolean]'
//		v
//	else if Object::toString.call(v) is '[object Function]'
//		"FN"
//	else
//		"#{pv} <#{typeof pv}>"
DUMP = function(o) {
  var dump;
  dump = function(o, level) {
    var cnt, ex, i, indent, item, len, n, pn, pv;
//		console.log "DDDDDDDDDDDDDD2: #{JSON.stringify o}"
    for (pn in o) {
      pv = o[pn];
      indent = "> ______________________________________________________________".substr(0, level + 2);
      try {
        //				console.log "#{indent}#{pn}: #{pv} (#{typeof pv})"
        if (Array.isArray(pv)) {
          if (pv.length === 0) {
            console.log(`${indent}${pn}: []`);
          } else {
            console.log(`${indent}${pn}: ARRAY:`);
            for (n = i = 0, len = pv.length; i < len; n = ++i) {
              item = pv[n];
              if (Object.prototype.toString.call(item) === '[object Object]') {
                console.log(`${indent}[${n}]: AO`);
                dump(pv, level + 1);
              } else {
                console.log(`${indent}_[${n}]: ${V.DUMP(pv)}`);
              }
            }
          }
        } else {
          if (Object.prototype.toString.call(pv) === '[object Object]') {
            cnt = CNT_OWN(pv);
            if (cnt) {
              console.log(`${indent}${pn}: OBJ (${cnt})`);
              dump(pv, level + 1);
            } else {
              console.log(`${indent}${pn}: OBJ EMPTY`);
            }
          } else {
            console.log(`${indent}${pn}: ${V.DUMP(pv)}`);
          }
        }
      } catch (error) {
        //				console.log "#{indent}#{pn} (#{typeof pv})"
        //			console.log "#{pn}"
        ex = error;
        console.log(`${indent}${pn}: ***ERR*** ${ex}`);
      }
    }
  };
  dump(o, 0);
};

// console.log "OOOOOOOOOOOOOOOOO"

//DUMP = (o, bRecursive=true, stringTruncateCnt=65535, levelNbr=0, bTerm=true, maxDepth=16, bMarkup=true) ->
//	indent = ->
//		if bMarkup
//			R.N.PERIOD levelNbr*10
//		else
//			""

//	if bTerm
//#BR = "_#{maxDepth}<br>"
//#BR = "$<br>"
//		BR = "<br>"
//	else
//		BR = " "

//	LLL = if bMarkup
//		R.L
//	else
//		ACTION: (s) -> s
//		CLS: (s) -> s
//		ERR: (s) -> s
//		EV: (s) -> s
//		RANGE: (s) -> s
//		TAG: (s) -> s
//		TR: (s) -> s
//		CELL_TYPESTYPE: (s) -> s

//#	REC = (o, bTerm) ->
//#		if levelNbr < maxDepth	#HACK
//#		DUMP o, bRecursive, stringTruncateCnt, levelNbr+1, bTerm, maxDepth, bMarkup
//#		else
//#		BR

//	callREC = (o) ->
//		if !o? or IS.PRIM(o) or (Array.isArray(o) and (o.length is 0 or (o.length is 1 and IS.PRIM o[0]))) or (IS.O(o) and CNT_ENUM_OWN(o) is 1 and IS.PRIM(o[Object.keys(o)[0]]))
//			if levelNbr < maxDepth
//				REC o, bTerm							#REC repeats this logic...
//			else
//				"#{o}#{BR}"
//		else
//			"#{BR}#{REC o, true}"

//	if o?
//		if Array.isArray o
//			if o.length is 0
//				"[]" + BR
//			else if o.length is 1 and typeof o[0] isnt "object"
//				"[#{REC o[0], false}]" + BR
//			else
//				s = ""
//				s += BR + "#{indent()}[" + BR
//				for item,j in o
//					s += "#{indent()}#{LLL.CLS "#{j}/#{o.length-1}"}"
//					s += callREC item
//				s + "#{indent()}]" + BR
//		else
//			switch typeof o
//				when "symbol"
//					LLL.TYPE("#{o} symbol") + BR
//				when "boolean"
//					"#{LLL.EV o}" + BR
//				when "number"
//					"#{LLL.TAG o}" + BR
//				when "string"
//					"\"#{LLL.RANGE(R.S.TRUNC o, stringTruncateCnt)}\"#{if bMarkup then "<span class='l-str-len'>#{o.length}</span>" else ""}" + BR
//				when "function"
//					"#{LLL.TR o}" + BR
//				when "object"
//					try
//						s = ""
//						for own k,v of o
//							s += "#{indent()}#{LLL.ACTION k}:"
//							s += callREC v
//						s
//					catch eo
//						"UNABLE TO ITERATE OBJECT PROPERTIES: #{eo}"
//				else
//					throw "type \"#{typeof o}\""
//	else if o is undefined
//		LLL.TYPE("undefined") + BR
//	else
//		LLL.ERR("null") + BR

//MOVE: to pre-processor
//H: what are the differences between these?
//UT: UT-ize
CNT = function(o) {
  a = [];
  while (true) {
    a.push.apply(a, Object.getOwnPropertyNames(o));
    if (!(o = Object.getPrototypeOf(o))) {
      break;
    }
  }
  return a.length;
};

CNT_OWN = function(o) {
  return Object.getOwnPropertyNames(o).length;
};

CNT_ENUM = function(o) {
  var k, n;
  n = 0;
  for (k in o) {
    n++;
  }
  return n;
};

CNT_ENUM_OWN = function(o) {
  return Object.keys(o).length;
};

KEYS = function(o) {
  a = [];
  while (true) {
    a.push.apply(a, Object.getOwnPropertyNames(o));
    if (!(o = Object.getPrototypeOf(o))) {
      break;
    }
  }
  return a;
};

KEYS_OWN = function(o) {
  return Object.getOwnPropertyNames(o);
};

KEYS_ENUM = function(o) {
  var k;
  a = [];
  for (k in o) {
    a.push(k);
  }
  return a;
};

KEYS_ENUM_OWN = function(o) {
  return Object.keys(o);
};

module.exports = {
  //	B:B
  //	CHILD_ELEVATE: (o, pn) ->
  //		if o[pn]
  //			@EXT_RVTMX o, o[pn]
  //			delete o[pn]
  //		o
  //	CLR_ENUM:CLR_ENUM
  //	A_CLR_ENUM:A_CLR_ENUM
  //	CONTAINS_INSENSITIVE:CONTAINS_INSENSITIVE
  //	DFS_BREAKABLE: DFS_BREAKABLE
  //	DELTA: (o0, o1) ->
  //		for k of o1
  //			delete o0[k]
  //		o0
  //	DIFF: (a, b) ->												# a-b
  //		o = Object.create null
  //		for pn in KEYS a
  //			o[pn] = b[pn] if pn !of b
  //		o
  DUMP: DUMP,
  EQUALS: function(o0, o1) {
    var compareTwo, leftChain, rightChain;
    leftChain = rightChain = null; //CLOSURE
    return compareTwo = function(o0, o1) {
      // remember that NaN===NaN returns false and isNaN(undefined) returns true
      //GETTING: 0x800a1389 - Microsoft JScript runtime error: Number expected
      //if !(o0 instanceof Object and o1 instanceof Object)
      if (Object.prototype.toString.call(o0) === "[object Object]" && Object.prototype.toString.call(o1) === "[object Object]") {
        if (Object.keys(o0).length === 0 && Object.keys(o1).length === 0) {
          return true;
        }
      } else {
        if (isNaN(o0) && isNaN(o1) && typeof o0 === 'number' && typeof o1 === 'number') {
          return true;
        }
      }
      if (o0 === o1) {
        // compare primitives and functions
        // check if both arguments reference the same object
        // especially useful on step when comparing prototypes
        return true;
      }
      if (o0 && !o1 || !o0 && o1) {
        //IMPROVED: seems like "no brainer???"
        return false;
      }
    };
  },
  // works in case when functions are created in constructor
  // comparing dates is a common scenario. Another built-ins?
  // we can even handle functions passed across iframes
  // precedence: instanceOf then && then ||
  //			if typeof o0 is 'function' and typeof o1 is 'function'									or
  //				o0 instanceof Date		and	o1 instanceof Date										or
  //				o0 instanceof RegExp	and	o1 instanceof RegExp									or
  //				o0 instanceof String	and	o1 instanceof String									r
  //				o0 instanceof Number	and	o1 instanceof Number
  //return o0.toString() is o1.toString()
  //return o0.toString().replace /~/g, "|"  is o1.toString().replace / /g, ""
  //				return o0.toString().replace(/\ /g, "") is o1.toString().replace /\ /g, ""

  //			#IMPROVED: seems like "no brainer???"
  //			return false if Object.keys(o0).length isnt Object.keys(o1).length

  //			# check for infinitive linking loops
  //			return false if leftChain.indexOf(o0) >= 0 || rightChain.indexOf(o1) >= 0
  //#
  //			# quick checking of one object being a subset of another
  //			#OPTIM: cache the structure of arguments[0]
  //			for k of o1
  //#return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if Object::hasOwnProperty.call(o0, k) isnt Object::hasOwnProperty.call(o1, k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //			for k of o0
  //#return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if Object::hasOwnProperty.call(o0, k) isnt Object::hasOwnProperty.call(o1, k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //				switch typeof o0[k]
  //					when 'object', 'function'
  //#CASE: NON-PRIMITIVE
  //						leftChain.push o0
  //						rightChain.push o1

  //						return false if !compareTwo o0[k], o1[k]

  //						leftChain.pop()
  //						rightChain.pop()
  //					else
  //#CASE: PRIMITIVE
  //						return false if o0[k] isnt o1[k]

  //			# at last checking prototypes as good as we can
  //			#home grown objects don't neccessary inherit from Object: return false if !(o0 instanceof Object && o1 instanceof Object)
  //			#return false if o0.isPrototypeOf(o1) || o1.isPrototypeOf(o0)
  //			return false if Object::isPrototypeOf.call(o0, o1) || Object::isPrototypeOf.call(o1, o0)
  //			return false if o0.constructor isnt o1.constructor
  //			return false if o0.prototype isnt o1.prototype

  //			true												#END: compareTwo

  //		for j in [1..arguments.length-1]
  //			leftChain = []
  //			rightChain = []

  //			return false if !compareTwo arguments[0], arguments[j]

  //		true#/EQUALS
  //	EQUALS_OBJECTS_THAT_ARE_CHAINED_TO_OBJECT_PROTOTYPE: (o0, o1) ->#NOT-USED
  //		leftChain=rightChain=null								#CLOSURE

  //		compareTwo = (o0, o1) ->
  //# remember that NaN===NaN returns false and isNaN(undefined) returns true
  //			return true if isNaN(o0) && isNaN(o1) && typeof o0 is 'number' && typeof o1 is 'number'

  //			# compare primitives and functions
  //			# check if both arguments reference the same object
  //			# especially useful on step when comparing prototypes
  //			return true if o0 is o1

  //			#IMPROVED: seems like "no brainer???"
  //			return false if o0 and !o1 or !o0 and o1

  //			# works in case when functions are created in constructor
  //			# comparing dates is a common scenario. Another built-ins?
  //			# we can even handle functions passed across iframes
  //			# precedence: instanceOf then && then ||
  //			if	typeof o0 is 'function'	&&	typeof o1 is 'function'									||
  //				o0 instanceof Date		&&	o1 instanceof Date										||
  //				o0 instanceof RegExp	&&	o1 instanceof RegExp									||
  //				o0 instanceof String	&&	o1 instanceof String									||
  //				o0 instanceof Number	&&	o1 instanceof Number
  //#return o0.toString() is o1.toString()
  //#return o0.toString().replace /~/g, "|"  is o1.toString().replace / /g, ""
  //				return o0.toString().replace(/\ /g, "") is o1.toString().replace /\ /g, ""

  //			# at last checking prototypes as good as we can
  //			return false if !(o0 instanceof Object && o1 instanceof Object)
  //			return false if o0.isPrototypeOf(o1) || o1.isPrototypeOf(o0)
  //			return false if o0.constructor isnt o1.constructor
  //			return false if o0.prototype isnt o1.prototype

  //			#IMPROVED: seems like "no brainer???"
  //			return false if Object.keys(o0).length isnt Object.keys(o1).length

  //			# check for infinitive linking loops
  //			return false if leftChain.indexOf(o0) >= 0 || rightChain.indexOf(o1) >= 0

  //			# quick checking of one object being a subset of another
  //			#OPTIM: cache the structure of arguments[0]
  //			for k of o1
  //				return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //			for k of o0
  //				return false if o1.hasOwnProperty(k) isnt o0.hasOwnProperty(k)
  //				return false if typeof o1[k] isnt typeof o0[k]

  //				switch typeof o0[k]
  //					when 'object', 'function'
  //#CASE: NON-PRIMITIVE
  //						leftChain.push o0
  //						rightChain.push o1

  //						return false if !compareTwo o0[k], o1[k]

  //						leftChain.pop()
  //						rightChain.pop()
  //					else
  //#CASE: PRIMITIVE
  //						return false if o0[k] isnt o1[k]

  //			true												#END: compareTwo

  //		for j in [1..arguments.length-1]
  //			leftChain = []
  //			rightChain = []

  //			return false if !compareTwo arguments[0], arguments[j]

  //		true#/EQUALS_OBJECTS_THAT_ARE_CHAINED_TO_OBJECT_PROTOTYPE
  //	I: (o) ->
  //		if typeof o is "number"
  //			o
  //		else
  //			parseInt o, 10
  //	IS_EMPTY: (o) ->
  //		for k of @KEYS o
  //			return false
  //		true

  CNT: CNT,
  CNT_OWN: CNT_OWN,
  CNT_ENUM: CNT_ENUM,
  CNT_ENUM_OWN: CNT_ENUM_OWN,
  INTERSECTS_ENUM: function(o0, o1) {
    var k;
    for (k in o0) {
      if (k in o1) {
        return true;
      }
    }
    return false;
  },
  KEYS: KEYS,
  KEYS_OWN: KEYS_OWN,
  KEYS_ENUM: KEYS_ENUM,
  KEYS_ENUM_OWN: KEYS_ENUM_OWN
};


//	N: (o) ->
//		if typeof o is "number"
//			o
//		else if R.RE.TEST_PLUS_MINUS_FLOAT.test o
//			parseFloat o, 10
//		else
//			throw o
//	SUB_SUP_PROP_VALUES_EQUALS: (sub, sup) ->
//		for k of sub
//			return false unless sup[k]?
//			return false unless R.O.EQUALS sub[k], sup[k]
//		true
