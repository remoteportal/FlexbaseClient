// Generated by CoffeeScript 2.3.0
var Classes, O, S, V, trace, util;

Classes = require('./Classes');

trace = require('./trace');

O = require('./O');

S = require('./S');

trace = require('./trace');

util = require('./Util');

V = require('./V');

// shared between Flexbase client, server, etc.
module.exports = {
  addMethodsAndCreateProxy: function(target, __bDirty = false) {
    var handler, myObj, pn, proxy, pv, wrapper;
    if (target.__notifyUpdateFN) {
      throw "already addMethodsAndCreateProxy!!!";
    }
    wrapper = {
      __commit: function() {
        this.__log("__commit");
        config.transaction.bOpen = false;
        //				flexbase.log "see me?"
        //				@__log "bOpen=#{config.transaction.bOpen}"
        //				@__log "bOpen=#{config.transaction.affectedMap}"
        //				config.transaction.affectedMap.set this, this
        return flexbase.transactionStart();
      },
      __delete: function() {
        this.__log("__delete");
        return target.__state = "DELETE";
      },
      //				config.transaction.affectedMap.set this, this
      __log: function() {
        var ref, ref1;
        //				logBase "Object #{@__id}#{if @__cn then " <#{@__cn}>" else ""}", s, o
        return util.logBase.apply(this, [(ref = (ref1 = this.__CLASS_NAME2) != null ? ref1 : this.__CLASS_NAME) != null ? ref : "FO", ...arguments]);
      },
      __save: function() {
        return new Promise((resolve, reject) => {
          var json, stripped;
          //					@__log "__save", this
          //					@__log "__save #{@__notifyUpdateFN}", @__notifyUpdateFN
          if (this.__bDirty) {
            if (trace.SAVE_ID) {
              this.__log(`__save ${this.__id}`);
            }
            this.__bDirty = false;
            //						O.LOG this
            //						@__log "A"
            //						O.LOG @__client
            //						@__log "B"
            //						O.LOG @__client.strip
            //						@__log "C"

            //TODO: look in config.targetMap
            stripped = this.__client.strip(this);
            // snapshot = Object.assign {}, stripped.... ==> json *is* the snapshot
            json = JSON.stringify(stripped);
            //						if @__id > 0
            //							config.upList.push this

            //						@__log "__save: upQ=#{config.upList.length}", stripped
            //						@__log "save: DONE", stripped
            //						Expo.FileSystem.writeAsStringAsync flexbase.path("object#{@__id}"), json
            return this.client.store.write(this.__id, json).then(() => {
              return resolve(this);
            }).catch(function(ex) {
              return reject(ex);
            });
          } else {
            //						@__log "__save #{@__id} SKIP"
            //LEARNED: MUST MUST MUST call resolve explicitly; can't just return promise (can only do that in promise chain)
            return resolve(this);
          }
        });
      },
      __who: function() {
        return this.__log(`Object ${this.__id}`);
      }
    };
    for (pn in wrapper) {
      pv = wrapper[pn];
      //			@log "ADD: #{pn}=#{pv}"
      target[pn] = pv;
    }
    target.__notifyUpdateFN = [];
    if (target.fname === 'Deanna') {
      target.__notifyUpdate = function(fn) {
        return target.__notifyUpdateFN.push(fn);
      };
    }
    //				@__log "set2 __notifyUpdateFN: length=#{target.__notifyUpdateFN.length}"
    //				@__log "66666666666", target.__notifyUpdateFN
    target.__bDirty = __bDirty;
    // C_ client only
    // S_ server only
    // CS_ client calls server
    // SC_ server calls client
    myObj = {
      CS_server3: function() {
        return console.log("CS_server3 called on server!");
      }
    };
    handler = {
      //			get: (target, pn) ->
      //				console.log("proxy get: #{pn}=#{target[pn]}");
      //				target[pn]
      get: function(target, pn) {
        if (pn === "server") {
          return function(...args) { //WORKS
            return "PeTeR";
          };
        } else if (pn === "server2") {
          return function(s) { //WORKS
            return s.toUpperCase();
          };
        } else if (pn === "server3") { //MATCH substring above
          //HELP: what if offline?
          //TODO: MINIMIZE BOILERPLATE
          //NOTE: there are TWO timeouts: waiting in queue to be sent, and time waiting on server.  For now, do both in one
          return function(...args) { //WORKS?
            args = [...args];
            //						@__log "server3 ARGS", args
            return new Promise((resolve, reject) => {
              //							@__log "server3", this
              if (flexbase.ws) {
                return invokeList.push({
                  guid: GUID(),
                  resolve: resolve,
                  reject: reject,
                  fo: this,
                  fn: pn, //+"!"
                  args: args,
                  msStart: Date.now()
                });
              } else {
                console.log("server3:OFFLINE");
                return reject("OFFLINE");
              }
            });
          };
        } else {
          
          //							# @ws may not be set yet
          //							flexbase.ws.send JSON.stringify
          //								target: "flexbase"
          //								cmd: "c-fb-invoke"
          //								fo:
          //									hello: "there"

          //							resolve
          //								aaa: "aaa"
          return target[pn];
        }
      },
      //			let result = origMethod.apply(this, args);
      //				console.log(propKey + JSON.stringify(args)
      //					+ ' -> ' + JSON.stringify(result));
      //				return result;
      deleteProperty: function(target, pn) {},
      //				console.log "proxy: deleteProperty: #{pn}"
      set: function(target, pn, pv) {
        //				console.log "proxy: set: #{pn}=#{pv} <#{typeof pv}>"

        //DUCK
        if (Object.prototype.toString.call(pv) === '[object Object]') {
          if (!pv.__id) {
            throw `{__id=${target.__id} property '${pn}': Cannot assign POJOs to FOs`;
          }
        }
        //TODO: ignore __id
        //				config.transaction.affectedMap.set this, this
        target[pn] = pv;
        return target.__bDirty = true;
      }
    };
    this.config.targetMap[target.__id] = target;
    proxy = new Proxy(target, handler);
    this.config.proxyMap[proxy.__id] = proxy;
    return proxy;
  },
  
  //	createSingletonByClass: (cn) ->
  //		@log "createSingletonByClass"
  //		@log "work? #{@config.authenticateID}"
  createSingletonByClass: function(cn) {
    var buildObject;
    buildObject = (cn, target) => {
      this.log(`buildObject: ${cn}`);
      //MOVE: do integrity checking at startup
      //TODO: @enumCheck
      //			util.enumCheck target, "NODE_SERVER_RPC,two,three"
      return new Promise((resolve, reject) => {
        var clo, fo, found, latest, pn, pv, ref, region;
        if (clo = Classes[cn]) {
          if ((latest = util.latestGet(clo)) != null) {
            //						@log "latest", latest, true
            if (target === "NODE_CLIENT") {
              fo = this.objectNew();
              // create RPC proxy
              if (region = latest["NODE_SERVER_RPC"]) {
                //							@log "found region"

                //TODO: scan all objects to see if one already has the correct type
                if (false) {
                  return found = true;
                } else {
                  ref = region.m;
                  //								O.LOG region.m
                  //									for pn,pv of region.m
                  //										fo[pn] = region.m[pn].bind this

                  //HERE
                  for (pn in ref) {
                    pv = ref[pn];
                    //										fo[pn] = =>
                    // package arguments
                    //											start sync call
                    this.log("I am a proxy");
                  }
                  return resolve(fo);
                }
              } else {
                //							region.m   WHAT IS THIS?
                throw "region not found";
              }
            } else {
              return this.logFatal(`target not supported yet: ${target}`);
            }
          } else {
            throw "not find latest";
          }
        } else {
          throw `${cn} not found`;
        }
      });
    };
    // what is my situation?
    //		O.LOG this
    this.log(`I am: ${this.__CLASS_NAME // ClientFB
}`);
    
    //		new Promise (resolve, reject) =>
    return buildObject(cn, "NODE_CLIENT"); //WARNING
  },
  //			.then (fo) =>
  //#				@log "got", fo, true

  //				#H #WRONG_PLACE!
  //				fo.emailHold "a@b.c"
  //				.then (emailHoldID) =>
  //					@log "emailHoldID",
  //						emailHoldID: emailHoldID
  //				.catch (ex) =>
  //					resolve "buildObject", ex

  //				resolve fo
  //			.catch (ex) =>
  //				resolve "objectNew", ex
  dateFlexCur: function() {
    //TODO: coordinate with server
    return new Date() * 1;
  },
  objectNew: function(cn) {
    var fo;
    //		@log "objectNew"
    return fo = {
      __bDirty: true,
      __client: this,
      __cn: cn,
      __dateCreated: this.dateFlexCur(),
      __id: this.config.newID--, // start -1
      __state: "CREATED"
    };
  },
  strip: function(o) {
    var k, one, out, v, v2;
    this.log(`strip ${o.__id}`);
    one = (v, k) => {
      var type;
      this.log(`one: ${V.KV(k, v)}`);
      type = V.TYPE(v);
      if (type === 'Date') {
        return v.valueOf();
      } else if (typeof v === 'object') { // if Object::toString.call(v) is '[object Object]'
        //			console.log "OBJ"
        if (v.__id > 0 || v.__id < 0) {
          //				console.log "FB obj"		#TODO: just replace THAT element
          if (!(v.__id > 0)) {
            throw "NEGATIVE __ID";
          }
          //HACK: late binding of referenced object's __id: idRecording: recording
          //				console.log "#{k} ----- #{v.__id}"
          if (k === "idRecording") {
            return v.__id;
          } else {
            return `$$${v.__id}`;
          }
        } else {
          return this.logFatal("NOT FLEXBASE OBJ", v);
        }
      } else {
        //			console.log "!OBJ"
        return v;
      }
    };
    out = {};
    for (k in o) {
      v = o[k];
      if (typeof v === "function") {
        continue;
      } else {
        //			@__log "?? #{Object::toString.call(v)}"
        if (Object.prototype.toString.call(v) === '[object Array]') {
          throw "NOTSUP";
          //				@__log "ARRAY"
          //TODO
          v2 = [];
        //				for item in v
        //					v2.push one(item, k)
        } else if (k === "__bDirty" || k === "__state") {
          //				@__log "SKIP: #{k}"
          continue;
        } else {
          //				@__log "primitive: #{k}"
          v2 = one(v, k);
        }
      }
      out[k] = v2;
    }
    this.log("done......", out);
    return out;
  },
  targetCheck: function(target) {
    return S.enumCheck(target, "ALL,FUSE,NODE_CLIENT,NODE_SERVER,NODE_SERVER_RPC,RN_LOCAL,WEB");
  }
};
